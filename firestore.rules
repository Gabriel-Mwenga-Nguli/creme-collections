
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Products: Publicly readable, admin-only write/delete (adjust admin check as needed)
    match /products/{productId} {
      allow read: if true;
      // Example: Allow write/delete if the user is an admin (you'd need to set custom claims for this)
      // allow write, delete: if request.auth != null && request.auth.token.admin == true;
      // For now, fallback to your timed rule for writes, but this should be secured.
      allow write, delete: if request.time < timestamp.date(2025, 7, 17); // Temporary, from your old rules
    }

    // Users: Users can read/write their own data.
    // User's public profile info might be readable by others if you choose.
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      // To allow admins to read/write user data (e.g., for support)
      // allow read, write: if request.auth != null && (request.auth.uid == userId || request.auth.token.admin == true);
    }

    // User subcollections (wishlist, addresses, messages)
    match /users/{userId}/wishlist/{itemId} {
      allow read, write, delete: if request.auth != null && request.auth.uid == userId;
    }
    match /users/{userId}/addresses/{addressId} {
      allow read, write, delete: if request.auth != null && request.auth.uid == userId;
    }
    match /users/{userId}/messages/{messageId} {
      // Users can create messages (outgoing). Only user can read their messages.
      // Support/admin might need broader read access based on roles.
      allow create: if request.auth != null && request.auth.uid == userId;
      allow read, update, delete: if request.auth != null && request.auth.uid == userId;
      // Example for admin to read messages:
      // allow read: if request.auth != null && (request.auth.uid == userId || request.auth.token.admin == true);
    }

    // Orders: Users can create their own orders and read their own orders.
    // Admins can read/update all orders.
    match /orders/{orderId} {
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow read: if request.auth != null && (request.auth.uid == resource.data.userId || request.auth.token.admin == true);
      // For now, fallback to your timed rule for updates/deletes by users, but this should be secured.
      // Admins should be the ones primarily updating status.
      allow update, delete: if request.auth != null && (request.auth.uid == resource.data.userId && request.time < timestamp.date(2025, 7, 17) || request.auth.token.admin == true) ;
    }

    // Fallback for any other paths - currently uses your time-based rule.
    // It's better to explicitly define rules for all collections.
    // If this rule is too broad, narrow it down or remove if all paths are covered above.
    match /{document=**} {
       allow read, write: if request.time < timestamp.date(2025, 7, 17);
    }
  }
}
